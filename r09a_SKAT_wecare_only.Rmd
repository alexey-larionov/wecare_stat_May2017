---
title: "SKAT_wecare_only"
output: html_document
---

started: Alexey Larionov, 27Mar2017  
last updated: Alexey Larionov, 03May2017  

# Summary

SKAT cbc vs ubc, without matching information, wecare only  

Efficient Resampling (ER) is used because this is the most accurate (?) method for  
P-assessment from small counts in SKAT package (Lee et al Biostatistics 2016)  
However, Efficient Resampling may become computationally heavy for large numbers of samples...  

Time to run:  
~3-5hrs for method.bin = "ER" (for is.accurate, MAP and adjusted QQPlot)  
~10-15 min with default method.bin (= "Hybrid"; using ER only for counts < 20?)  

is.accurate and MAP are only reported my resampling methods (ER or ER.A)  

# start_section

```{r start_section}

# Start time
Sys.time()

# Folders
base_folder="/analysis/mtgroup_share/users/alexey/wecare_only_stat_05.17"
setwd(base_folder)
scripts_folder <- "scripts"
source_data_folder <- "source_data"
interim_data_folder <- "interim_data"
results_folder <- "results"

# Libraries
library(SKAT)

```

# load_data

```{r load_data}

load(paste(interim_data_folder, "r08_filter_by_variant_effect_wecare_only.RData", sep="/"))

```

# check_data

```{r check_data}

dim(genotypes.mx)
class(genotypes.mx)
genotypes.mx[1:5,1:5]

dim(genes_aggr_info.df)
class(genes_aggr_info.df)
genes_aggr_info.df[1:5,]

dim(kgen.df)
colnames(kgen.df)
kgen.df[1:5,1:5]

dim(exac.df)
colnames(exac.df)
exac.df[1:5,1:5]

dim(variants.df)
str(variants.df)
variants.df[1:5,1:5]

dim(phenotypes.df)
str(phenotypes.df)
phenotypes.df[1:5,1:5]

# Check consistency of rownames and colnames
sum(colnames(genotypes.mx) != rownames(phenotypes.df))

sum(rownames(genotypes.mx) != rownames(kgen.df))
sum(rownames(genotypes.mx) != rownames(exac.df))
sum(rownames(genotypes.mx) != rownames(variants.df))

```

# prepare_data_for_analysis

No missed data in outcomes, covariates or eigenvectors  
Impute missed data for genotypes  

```{r prepare_data_for_analysis}

# Outcomes
Y <- phenotypes.df$cc
sum(is.na(Y)) # 0

# Genotypes: transpose non-aggregated variants
G <- t(genotypes.mx)

# DO NOT impute missed data (they are handled by SKAT)
#G <- apply(G, 2, function(v) { ifelse(is.na(v), mean(v, na.rm=T), v) })
sum(is.na(G))/(ncol(G)*nrow(G)) # ~2.7%

# Eigenvectors
E <- as.matrix(phenotypes.df[,c("eig1","eig2")])
sum(is.na(E)) # 0

# Treatment
hormone <- phenotypes.df$hormone
chemo <- phenotypes.df$chemo_cat != "no"
treatment <- as.integer(chemo | hormone)
sum(is.na(treatment)) # 0

# Number of pregnancies
num_preg <- as.integer(phenotypes.df$num_preg)
sum(is.na(num_preg)) # 0

# Lobular pathology - excluded because of a missed vcalue?
#lobular <- phenotypes.df$hist_cat == "lobular"
#sum(is.na(lobular)) # 1

# Covariates: 
C <- cbind(treatment, num_preg)
sum(is.na(C)) # 0

# Genes
genes=genes_aggr_info.df$gene
sum(is.na(genes)) # 0

# Clean-up
rm(chemo, hormone, treatment, num_preg) # lobular

```

# prepare_empty_matrix_for_results

```{r prepare_empty_matrix_for_results}

# Prepare header
header=c("gene", "num_var", 
         "svt_p", "svt_is_accurate", "svt_map", 
         "burden_p",  "burden_is_accurate", "burden_map", 
         "skat_p", "skat_is_accurate", "skat_map")

# Write header to output matrix 
# (do not use data frame here: it may cause issues with rbind)
result.mx <- matrix(ncol=11, nrow=0) 
colnames(result.mx) <- header

# Clean-up
rm(header)

```

# SKAT

Assuming that no errors generated by the SKAT functions (accertained in a separate script)  
Ignoring warnings about imputation and flipping (captured and assessed in a separate script)  

In 8 cases there was a warning message (for SKAT and Burden):  
ALL SNPs have either high missing rates or no-variation. P-value=1  
These cases produce contraintuitive output and will be excluded later (see comments below)  

```{r SKAT, warning=FALSE}

# Calculate SKAT null model (the same for all genes and all tests)
skat_null <- SKAT_Null_Model(Y ~ C + E, out_type="D")
# D for the dichotomous outcome

# For each gene
for(gene in genes){
  
  # Get variants
  vars <- as.vector(variants.df[variants.df$SYMBOL==gene, "SplitVarID"])
  
  # Get number of variants
  num_vars <- length(vars)
    
  # Get vector of genotypes  
  X <- G[,vars]

  # If there is one variant only
  if(num_vars == 1){

    # Aggregating variants (burden or skat) is irrelevant
    burden_p <- NA
    burden_is_accurate <- NA
    burden_map <- NA
    skat_p <- NA
    skat_is_accurate <- NA
    skat_map <- NA

    # Calculate Single-variant test (svt)
    svt <- SKATBinary_Single(X, skat_null, method.bin = "ER")
    svt_p <- svt$p.value
    svt_is_accurate <- svt$is.accurate # Was resampling suficient ?
    svt_map <- svt$MAP # Minimal Acheaved P-value (for adjusted QQ-plot)
    rm(svt)
    
  # If there are several variants in the gene  
  }else{
    
    # Single-variant test is irrelevant
    svt_p <- NA
    svt_is_accurate <- NA
    svt_map <- NA

    # Calculate burden test with default weights beta[1,25]
    burden_test <- SKATBinary(X, skat_null, method="Burden", method.bin = "ER")
    burden_p <- burden_test$p.value
    burden_is_accurate <- burden_test$is.accurate # Was resampling suficient ?
    burden_map <- burden_test$MAP # Minimal Acheaved P-value (for adjusted QQ-plot)
    rm(burden_test)

    # Calculate SKAT variance-based test with default weights beta[1,25]
    skat_test <- SKATBinary(X, skat_null, method="SKAT", method.bin = "ER")
    skat_p <- skat_test$p.value
    skat_is_accurate <- skat_test$is.accurate # Was resampling suficient ?
    skat_map <- skat_test$MAP # Minimal Acheaved P-value (for adjusted QQ-plot)
    rm(skat_test)
    
  }
  
  # Convert NULLs to NAs: to account for occasional contra-intuitive returns from SKATBinary, e.g. 
  # SKATBinary does not return is.accurate and MAP for genes with high NAs in all variants,
  # at the same time it returns p=1 for such genes.  There was 8 such genes in the dataset:
  # HNMT, PPARGC1B, POM121L12, HEPACAM2, CCAR2, PALD1, CEP290, MVP;
  # they will be excluded from results data frame in the next chunk. 
  if(is.null(gene)) NA->gene
  if(is.null(num_vars)) NA->num_vars
  if(is.null(svt_p)) NA->svt_p
  if(is.null(svt_is_accurate)) NA->svt_is_accurate
  if(is.null(svt_map)) NA->svt_map
  if(is.null(burden_p)) NA->burden_p
  if(is.null(burden_is_accurate)) NA->burden_is_accurate
  if(is.null(burden_map)) NA->burden_map
  if(is.null(skat_p)) NA->skat_p
  if(is.null(skat_is_accurate)) NA->skat_is_accurate
  if(is.null(skat_map)) NA->skat_map
  
  # Add results to matrix
  result.mx <- rbind(result.mx, c(gene, num_vars, 
                svt_p, svt_is_accurate, svt_map, 
                burden_p, burden_is_accurate, burden_map, 
                skat_p, skat_is_accurate, skat_map))

  # Clean-up
  rm(vars, num_vars, X, 
     svt_p, svt_is_accurate, svt_map, 
     burden_p, burden_is_accurate, burden_map, 
     skat_p, skat_is_accurate, skat_map)

} # next gene

# explore result
dim(result.mx)

# Clean-up
rm(Y, G, E, C, gene, genes, skat_null)

```

# explore_update_and_save_result

```{r explore_update_and_save_result}

# Convert factors to vectors
genes_aggr_skat.df <- as.data.frame(result.mx)
genes_aggr_skat.df$gene <- as.vector(genes_aggr_skat.df$gene)
genes_aggr_skat.df$num_var <- as.integer(as.vector(genes_aggr_skat.df$num_var))
genes_aggr_skat.df$svt_p <- as.double(as.vector(genes_aggr_skat.df$svt_p))
genes_aggr_skat.df$svt_is_accurate <- as.logical(as.vector(genes_aggr_skat.df$svt_is_accurate))
genes_aggr_skat.df$svt_map <- as.double(as.vector(genes_aggr_skat.df$svt_map))
genes_aggr_skat.df$burden_p <- as.double(as.vector(genes_aggr_skat.df$burden_p))
genes_aggr_skat.df$burden_is_accurate <- as.logical(as.vector(genes_aggr_skat.df$burden_is_accurate))
genes_aggr_skat.df$burden_map <- as.double(as.vector(genes_aggr_skat.df$burden_map))
genes_aggr_skat.df$skat_p <- as.double(as.vector(genes_aggr_skat.df$skat_p))
genes_aggr_skat.df$skat_is_accurate <- as.logical(as.vector(genes_aggr_skat.df$skat_is_accurate))
genes_aggr_skat.df$skat_map <- as.double(as.vector(genes_aggr_skat.df$skat_map))

# Check data
dim(genes_aggr_skat.df)
str(genes_aggr_skat.df)
summary(genes_aggr_skat.df)

# Exclude odd genes with high NAs (>15%) in all variants
# HNMT, PPARGC1B, POM121L12, HEPACAM2, CCAR2, PALD1, CEP290, MVP
# See comment about converting NULLs to NAs in the previous chunk
odd_genes <- is.na(genes_aggr_skat.df$burden_is_accurate) & !is.na(genes_aggr_skat.df$burden_p)
genes_aggr_skat.df[odd_genes,]

genes_aggr_skat.df <- genes_aggr_skat.df[!odd_genes,]
rownames(genes_aggr_skat.df) <- genes_aggr_skat.df$gene

genes_aggr_info.df <- genes_aggr_info.df[!odd_genes,]
sum(rownames(genes_aggr_skat.df) != rownames(genes_aggr_info.df))

genes_aggr_skat.df <- cbind(genes_aggr_skat.df, aggregated_MAC=genes_aggr_info.df$aggregated_MAC)

str(genes_aggr_skat.df)
summary(genes_aggr_skat.df)

# write result table to text file
results_file <- paste(results_folder, "r09a_SKAT_wecare_only.txt", sep="/")
write.table(genes_aggr_skat.df, file=results_file, quote=FALSE, sep="\t")

# Clean-up
rm(odd_genes, result.mx, results_file, genes_aggr_info.df)

```

# compare_p_estimates_between_methods

```{r compare_p_estimates_between_methods}

# svt vs burden vs skat
mean_p_values <- 
  c(mean(genes_aggr_skat.df$svt_p, na.rm=TRUE), 
    mean(genes_aggr_skat.df$burden_p, na.rm=TRUE),
    mean(genes_aggr_skat.df$skat_p, na.rm=TRUE))
names(mean_p_values) <- c("single", "burden", "skat")
barplot(mean_p_values, main="Compare mean p-values")

# burden vs skat
plot(genes_aggr_skat.df$burden_p, 
     genes_aggr_skat.df$skat_p, 
     main="P-values: Burden vs SKAT",
     xlab="Burden", ylab="SKAT")

cor.test(genes_aggr_skat.df$burden_p, 
         genes_aggr_skat.df$skat_p)

# Clean-up
rm(mean_p_values)

```

# qq_plots

```{r qq_plots}

# Remove NAs when not needed for the QQ plots
svt_p <- genes_aggr_skat.df$svt_p[!is.na(genes_aggr_skat.df$svt_p)]
length(svt_p) # 4,688
summary(svt_p)

svt_map <- genes_aggr_skat.df$svt_map[!is.na(genes_aggr_skat.df$svt_map)]
length(svt_map)
summary(svt_map)

burden_p <- genes_aggr_skat.df$burden_p[!is.na(genes_aggr_skat.df$burden_p)]
length(burden_p) # 4,421
summary(burden_p)

burden_map <- genes_aggr_skat.df$burden_map[!is.na(genes_aggr_skat.df$burden_map)]
length(burden_map)
summary(burden_map)

skat_p <- genes_aggr_skat.df$skat_p[!is.na(genes_aggr_skat.df$skat_p)]
length(skat_p)
summary(skat_p)

skat_map <- genes_aggr_skat.df$skat_map[!is.na(genes_aggr_skat.df$skat_map)]
length(skat_map)
summary(skat_map)

# Combine svt with burden/skat
svt_burden_p <- ifelse(is.na(genes_aggr_skat.df$svt_p), genes_aggr_skat.df$burden_p, genes_aggr_skat.df$svt_p)
sum(is.na(svt_burden_p))
length(svt_burden_p)

svt_burden_map <- ifelse(is.na(genes_aggr_skat.df$svt_map), genes_aggr_skat.df$burden_map, genes_aggr_skat.df$svt_map)
sum(is.na(svt_burden_map))
length(svt_burden_map)

svt_skat_p <- ifelse(is.na(genes_aggr_skat.df$svt_p), genes_aggr_skat.df$skat_p, genes_aggr_skat.df$svt_p)
sum(is.na(svt_skat_p))
length(svt_skat_p)

svt_skat_map <- ifelse(is.na(genes_aggr_skat.df$svt_map), genes_aggr_skat.df$skat_map, genes_aggr_skat.df$svt_map)
sum(is.na(svt_skat_map))
length(svt_skat_map)

# SKAT-adjusted qq plots (with unadjusted in grey)
QQPlot_Adj(svt_p, svt_map, main="CBC vs UBC: Single variant test\n4,688 genes with 1 variant")
QQPlot_Adj(burden_p, burden_map, main="CBC vs UBC: Burden\n4,421 genes with >1 variant")
QQPlot_Adj(skat_p, skat_map, main="CBC vs UBC: SKAT\n4,421 genes with >1 variant")

QQPlot_Adj(svt_burden_p, svt_burden_map, main="CBC vs UBC: SVT + Burden\nall 9,109 genes")
QQPlot_Adj(svt_skat_p, svt_skat_map, main="CBC vs UBC: SVT + SKAT\nall 9,109 genes")

# SKAT-adjusted qq plots (w/o unadjusted)
QQPlot_Adj(svt_p, svt_map, Is.unadjsted=FALSE, main="CBC vs UBC: Single variant test\n4,688 genes with 1 variant")
QQPlot_Adj(burden_p, burden_map, Is.unadjsted=FALSE, main="CBC vs UBC: Burden\n4,421 genes with >1 variant")
QQPlot_Adj(skat_p, skat_map, Is.unadjsted=FALSE, main="CBC vs UBC: SKAT\n4,421 genes with >1 variant")

QQPlot_Adj(svt_burden_p, svt_burden_map, Is.unadjsted=FALSE, main="CBC vs UBC: SVT + Burden\nall 9,109 genes")
QQPlot_Adj(svt_skat_p, svt_skat_map, Is.unadjsted=FALSE, main="CBC vs UBC: SVT + SKAT\nall 9,109 genes")

# --- Look at the genes with aggregated MAC >= 10  --- #

selected_genes <- genes_aggr_skat.df$aggregated_MAC >= 10
sum(selected_genes)

svt_burden_p_selected <- svt_burden_p[selected_genes]
svt_burden_map_selected <- svt_burden_map[selected_genes]

svt_skat_p_selected <- svt_skat_p[selected_genes]
svt_skat_map_selected <- svt_skat_map[selected_genes]

# SKAT-adjusted qq plots (with unadjusted in grey)
QQPlot_Adj(svt_burden_p_selected, svt_burden_map_selected, 
           main="CBC vs UBC: SVT + Burden\n2,168 genes (aggr MAC >= 10)")
QQPlot_Adj(svt_skat_p_selected, svt_skat_map_selected, 
           main="CBC vs UBC: SVT + SKAT\n2,168 genes (aggr MAC >= 10)")

# SKAT-adjusted qq plots (w/o unadjusted)
QQPlot_Adj(svt_burden_p_selected, svt_burden_map_selected, Is.unadjsted=FALSE, 
           main="CBC vs UBC: SVT + Burden\n2,168 genes (aggr MAC >= 10)")
QQPlot_Adj(svt_skat_p_selected, svt_skat_map_selected, Is.unadjsted=FALSE, 
           main="CBC vs UBC: SVT + SKAT\n2,168 genes (aggr MAC >= 10)")

# --- Clean-up --- #

rm(svt_p, svt_map, burden_p, burden_map, skat_p, skat_map, 
   svt_burden_p, svt_burden_map, svt_burden_p_selected, svt_burden_map_selected,
   svt_skat_p, svt_skat_map, svt_skat_p_selected, svt_skat_map_selected, 
   selected_genes)

```

# data_summary

```{r data_summary}

dim(genotypes.mx)
class(genotypes.mx)
genotypes.mx[1:5,1:5]

dim(kgen.df)
colnames(kgen.df)
kgen.df[1:5,1:5]

dim(exac.df)
colnames(exac.df)
exac.df[1:5,1:5]

dim(variants.df)
str(variants.df)
variants.df[1:5,1:5]

dim(phenotypes.df)
str(phenotypes.df)
phenotypes.df[1:5,1:5]

dim(genes_aggr_skat.df)
str(genes_aggr_skat.df)
genes_aggr_skat.df[1:5,1:5]

# Check consistency of rownames and colnames
sum(colnames(genotypes.mx) != rownames(phenotypes.df))

sum(rownames(genotypes.mx) != rownames(kgen.df))
sum(rownames(genotypes.mx) != rownames(exac.df))
sum(rownames(genotypes.mx) != rownames(variants.df))

```

# save_results

```{r save_results}

save.image(paste(interim_data_folder, "r09a_SKAT_wecare_only.RData", sep="/"))

```

# final_section

```{r final_section}

ls()
sessionInfo()
Sys.time()

```
